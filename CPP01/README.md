###Exercise 00: BraiiiiiiinnnzzzZ
Сначала реализуйте `класс Zombie`. У него есть строковый приватный атрибут `name`.
Добавьте функцию-`void announce( void );`
в `класс Zombie`. Зомби объявляют о себе следующим образом:

```<name>: BraiiiiiiinnnzzzZ...```

Не печатайте угловые скобки (< and >). Для зомби с именем Foo 
сообщение будет выглядеть следующим образом:

``    Foo: BraiiiiiiinnnzzzZ...``

Затем реализуйте две следующие функции:

`Zombie* newZombie( std::string name );`

Он создает зомби, присваивает ему имя и возвращает его, чтобы вы могли 
использовать его за пределами области действия функции.

`• void randomChump( std::string name );`

Он создает зомби, дает ему имя, и зомби объявляет о себе.
В чем, собственно, смысл упражнения? Вы должны определить, в каком случае лучше выделять зомби на стеке или в куче.
Зомби должны быть уничтожены, когда они вам больше не нужны. Деструктор должен выводить сообщение с именем зомби для целей отладки.

###Exercise 01: Moar brainz!

Пора создать орду зомби!
Реализуйте следующую функцию в соответствующем файле:
``` c++
Zombie* zombieHorde( int N, std::string name );
```
Она должна выделить N объектов зомби за одно распределение.
Затем она должна инициализировать зомби, давая каждому из них имя, переданное в качестве параметра. Функция возвращает указатель на первого зомби.
Проведите собственные тесты, чтобы убедиться, что ваша функция `zombieHorde()` работает так, как ожидается. Попробуйте вызвать функцию `announce()` для каждого из зомби.
Не забудьте удалить всех зомби и проверить на утечку памяти.

###Exercise 02: HI THIS IS BRAIN

Напишите программу, которая содержит:
- Строковую переменную, инициализированную в "HI THIS IS BRAIN". - stringPTR: указатель на строку.
- stringREF: Ссылка на строку.
  Ваша программа должна вывести:
- Адрес памяти строковой переменной.
- Адрес памяти, хранящийся в stringPTR.
- Адрес памяти, хранящийся в stringREF.
  А затем:
- Значение строковой переменной.
- Значение, на которое указывает stringPTR. - Значение, на которое указывает stringREF.
  
Вот и все, никаких хитростей. Целью этого упражнения является разъяснение ссылок, которые могут показаться совершенно новыми. Хотя есть некоторые небольшие различия, это другой синтаксис для того, что вы уже делаете: работа с адресами.

###Exercise 03: Unnecessary violence


###Exercise 04: Sed is for losers1

Создайте программу, которая принимает три параметра
в следующем порядке: имя файла и две строки, s1 и s2.

Он откроет файл <filename> и скопирует его содержимое в новый файл <filename>.replace,
заменяя каждое вхождение s1 на s2.
Использование функций манипулирования файлами на языке C запрещено и будет считаться мошенничеством. Разрешены все функции-члены класса std::string, кроме replace. Используйте их с умом!
Конечно, обрабатывайте неожиданные входы и ошибки. Вы должны создать и сдать собственные тесты, чтобы убедиться, что ваша программа работает так, как ожидается.

###Exercise 05: Harl 2.0

Вы знаете Харла? Мы все знаем, не так ли? Если вы не знаете, найдите ниже, какие комментарии делает Харл. Они классифицированы по уровням:

* **"DEBUG" level**: Отладочные сообщения содержат контекстную информацию. В основном они используются для диагностики проблем.

_Пример:_ "Я люблю, когда к моему бургеру 7XL-double-cheese-triple-pickle-special- ketchup добавляют дополнительный бекон. Правда!"

* **"INFO" level**: Эти сообщения содержат обширную информацию. Они полезны для отслеживания выполнения программы в производственной среде.

_Пример:_ "Не могу поверить, что добавление дополнительного бекона стоит больше денег. Вы положили недостаточно бекона в мой бургер! Если бы положили, я бы не просил добавки!".
* **"WARNING" level**: Предупреждающие сообщения указывают на потенциальную проблему в системе. Однако ее можно решить или проигнорировать.

_Пример:_ "Я думаю, что заслуживаю получить бесплатно немного дополнительного бекона. Я хожу сюда уже много лет, в то время как вы начали работать здесь с прошлого месяца".

* **" ERROR" level**: Эти сообщения указывают на то, что произошла неустранимая ошибка. Обычно это критическая проблема, требующая ручного вмешательства.
  
_Пример:_ "Это неприемлемо! Я хочу поговорить с менеджером сейчас"

###### Вы собираетесь автоматизировать Harl. Это будет несложно, поскольку он всегда говорит одно и то же. Вы должны создать класс Harl со следующими частными функциями-членами:

```c++
 void debug( void );
 void info( void );
 void warning( void ); 
 void error( void );
```
######Harl также имеет функцию public member, которая вызывает четыре функции member выше в зависимости от уровня, переданного в качестве параметра:

```c++
void    complain( std::string level );
```
Цель этого упражнения - использовать указатели на функции-члены. Это не предложение. Harl должен жаловаться, не используя для этого целый строй if/else if/else. Он не думает дважды!
Создайте и сдайте тесты, чтобы показать, что Harl жалуется часто. Вы можете использовать комментарии к примерам.
